/**
@ingroup AllocatorGroup
@fn void* AlignedAllocator::allocate(std::size_t size)
@brief Allocates a memory block from the pool.
@param[in] size Requested block size in bytes.
@return Pointer to the aligned memory block.
@throw std::bad_alloc Exception thrown if the requested memory size exceeds the pool's capacity.

@details
**Description of the @ref AlignedAllocator::allocate(std::size_t size) method**
1. The method allocates a memory block from the pool, ensuring that the returned pointer is aligned to the boundary specified by the `alignment` parameter of the constructor. Subsequent allocations also maintain proper alignment. The method performs pointer arithmetic and bitwise operations to compute the aligned address, checks the pool's boundaries, and updates the current position for future allocations.
2. The method returns a generic pointer of type `void*`, which can point to data of any type. This allows the caller to cast the pointer to the desired type (e.g., `int*` or `float*`), providing flexibility.
3. The `current` pointer (of type `std::uint8_t*`), which points to the current position in the memory pool, is converted to an integer type `std::uintptr_t` using `reinterpret_cast`. Pointers (`std::uint8_t*`) cannot be directly used for bitwise operations, as this depends on the type's size. `std::uintptr_t` is an unsigned integer type large enough to hold a pointer's address (e.g., 64 bits on a 64-bit system). This conversion enables arithmetic and bitwise operations on the memory address. The `std::uintptr_t` type ensures that the pointer's address can be safely stored and manipulated as a number.
4. The expression `std::uintptr_t aligned = (curr + alignment - 1) & ~(alignment - 1);` computes the next aligned memory address, a multiple of `alignment`. This is achieved in two steps:
    - `curr + alignment - 1` rounds up the current address by adding `alignment - 1`. This ensures the result is at least the next alignment boundary. For example, if `curr = 100` and `alignment = 16`, then `100 + 16 - 1 = 115`.
    - `~(alignment - 1)` creates a bitmask to clear the lower bits of the address. For example, for `alignment = 16` (binary `10000`), `alignment - 1 = 15` (binary `01111`), and `~(alignment - 1) = ~01111 = 11110000` (in hexadecimal, `0xFFFFFFF0` for 32 bits). This mask zeros out the lower bits corresponding to the alignment value.
    - The bitwise AND operation (`&`) applies the mask to the rounded address, clearing the lower bits to obtain an address that is a multiple of `alignment`. For the example above: `115 & 0xFFFFFFF0 = 112` (binary `1110000`), which is a multiple of 16.
5. Address alignment is necessary to ensure the returned pointer meets the `alignment` requirements (e.g., 16 or 64 bytes), which is critical for optimizations (e.g., SIMD instructions) or hardware requirements.
6. The `aligned` variable holds the numeric value of the aligned address.
7. The numeric address `aligned` (of type `std::uintptr_t`) is converted back to a pointer of type `std::uint8_t*` using `reinterpret_cast`. Since a `std::uintptr_t` number is not a pointer and cannot be used to access memory, this conversion allows the address to be interpreted as a pointer to a byte array, enabling pointer arithmetic and return to the caller.
8. The `std::uint8_t` type represents the smallest addressable unit of memory, making it convenient for pool management and pointer arithmetic (e.g., adding `size` to update the position).
9. At the step `if (aligned_ptr + size > base + pool_size) { throw std::bad_alloc(); }`, the method checks whether the requested memory block of `size` bytes, starting at the aligned address `aligned_ptr`, fits within the memory pool's boundaries.
     **Logic**:
         - The expression `aligned_ptr + size` calculates the address following the end of the requested block (the end of the allocated section).
         - The expression `base + pool_size` determines the end of the memory pool, where `base` is the starting address of the pool, and `pool_size` is its total size.
         - If `aligned_ptr + size` exceeds `base + pool_size`, the allocation is impossible, as the block would extend beyond the pool's boundaries.
     This check prevents pool overflow, ensuring the allocator does not allocate memory beyond the available space.
     If the allocation is not possible, a `std::bad_alloc` exception is thrown, signaling to the caller that there is insufficient memory.
10. At the step `current = aligned_ptr + size;`, the `current` pointer is updated to point to the address following the allocated block (`aligned_ptr + size`). This advances the current position in the pool, preparing it for the next call to `allocate`.
11. Updating `current` tracks which portion of the pool has been allocated, allowing the allocator to sequentially distribute memory without overlaps.

@return
Returns the `aligned_ptr` pointer (of type `std::uint8_t*`), cast to `void*` as per the function's signature.
Returning `void*` ensures universality, allowing the caller to cast the pointer to any desired type (e.g., `double*` or `struct MyType*`). This is standard practice for allocators working with raw memory.
The caller receives an aligned memory address ready for use.

@par Example:
@code
AlignedAllocator alloc(1024, 64);
void* ptr = alloc.allocate(256); // Allocates a 256-byte block aligned to 64 bytes
@endcode

@warning
- Ensure `size` is non-zero, as allocating a zero-sized block may lead to undefined behavior or an empty allocation, depending on the implementation.
- If the requested `size` is too large and exceeds the pool's boundaries (`base + pool_size`), the method will throw `std::bad_alloc`. Verify the available pool size before calling.
- The alignment set in the constructor must be a power of 2. Incorrect alignment may result in misaligned addresses, though the method itself does not validate this.
 */