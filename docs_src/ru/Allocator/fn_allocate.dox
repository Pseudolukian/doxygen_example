/**
@ingroup AllocatorGroup
@fn void* AlignedAllocator::allocate(std::size_t size)
@brief Выделяет блок памяти из пула.
@param[in] size Запрашиваемый размер блока в байтах.
@return Указатель на выровненный блок памяти.
@throw std::bad_alloc Поднимается исключение, если запрашиваемый размер памяти превышает объём пула.

@details
**Описание метода @ref AlignedAllocator::allocate(std::size_t size)**
1. Метод выделяет блок памяти из пула, гарантируя, что возвращаемый указатель выровнен по границе, заданной параметром `alignment` конструктора. Последующие выделения также сохраняют правильное выравнивание. Метод выполняет арифметику указателей и побитовые операции для вычисления выровненного адреса, проверяет границы пула и обновляет текущую позицию для следующих выделений.
2. Метод возвращает универсальный указатель типа void*, который может указывать на данные любого типа. Он позволяет вызывающему коду самостоятельно привести указатель к нужному типу (например, `int*` или `float*`), обеспечивая гибкость.
3. Указатель `current` (типа `std::uint8_t*`), указывающий на текущую позицию в пуле памяти, преобразуется в целое число типа `std::uintptr_t` с помощью `reinterpret_cast`, так как указатели (`std::uint8_t*`) нельзя напрямую использовать для побитовых операций, так как это зависит от размера типа, а `std::uintptr_t` — это беззнаковый целый тип, достаточно большой, чтобы хранить адрес указателя (например, 64 бита на 64-битной системе). Преобразование позволяет выполнять арифметические и побитовые операции на адресе памяти. Тип `std::uintptr_t` гарантирует, что адрес указателя можно безопасно хранить и манипулировать как числом.
4. Конструкция `std::uintptr_t aligned = (curr + alignment - 1) & ~(alignment - 1);` вычисляет следующий выровненный адрес памяти, кратный значению `alignment`. Это делается с помощью двух шагов:
    - `curr + alignment - 1` — округляет текущий адрес вверх, добавляя `alignment - 1`. Это гарантирует, что результат будет не меньше следующей границы выравнивания. Например, если `curr = 100` и `alignment = 16`, то `100 + 16 - 1 = 115`.
    - `~(alignment - 1)`— создаёт битовую маску для очистки младших битов адреса. Например, для `alignment = 16` (двоичное `10000`), `alignment - 1 = 15` (двоичное `01111`), а `~(alignment - 1) = ~01111 = 11110000` (в шестнадцатеричной системе `0xFFFFFFF0` для 32 бит). Эта маска обнуляет младшие биты, соответствующие значению выравнивания.
    - Побитовая операция `&` применяет маску к округлённому адресу, обнуляя младшие биты, чтобы получить адрес, кратный `alignment`. Для примера выше: `115 & 0xFFFFFFF0 = 112` (двоичное `1110000`), что кратно 16.
5. Выравнивание адреса необходимо, чтобы возвращаемый указатель соответствовал требованиям `alignment` (например, 16 или 64 байта), что критично для оптимизаций (например, SIMD-инструкций) или аппаратных требований.
6. Переменная `aligned` содержит числовое значение выровненного адреса.
7. Числовой адрес `aligned` (типа `std::uintptr_t`) преобразуется обратно в указатель типа `std::uint8_t*` с помощью `reinterpret_cast`, так как число `std::uintptr_t` не является указателем и не может использоваться для доступа к памяти. Преобразование в `std::uint8_t*` позволяет интерпретировать адрес как указатель на массив байтов, с которым можно выполнять арифметику указателей и возвращать его вызывающему коду.
8. Тип `std::uint8_t`представляет минимальную адресуемую единицу памяти, что удобно для управления пулом и арифметики указателей (например, прибавления `size` для обновления позиции).
9. На этапе `if (aligned_ptr + size > base + pool_size) { throw std::bad_alloc(); }` проверяется, помещается ли запрашиваемый блок памяти размером `size`, начиная с выровненного адреса `aligned_ptr`, в пределах пула памяти.
     **Логика работы**:
         - Выражение `aligned_ptr + size` вычисляет адрес, следующий за концом запрашиваемого блока (конец выделяемого участка).
         - Выражение `base + pool_size` определяет конец пула памяти, где `base` — начальный адрес пула, а `pool_size` — его общий размер.
         - Если `aligned_ptr + size` превышает `base + pool_size` — выделение невозможно, так как блок выходит за границы пула.
     Такая проверка предотвращает переполнение пула, гарантируя, что аллокатор не выделит память за пределами доступного пространства.
     Если выделение невозможно, выбрасывается исключение `std::bad_alloc`, сигнализирующее вызывающему коду, что памяти недостаточно.

10. На этапе `current = aligned_ptr + size;` указатель `current` обновляется, чтобы указывать на адрес, следующий за выделенным блоком (`aligned_ptr + size`). Это перемещает текущую позицию в пуле, подготавливая её для следующего вызова `allocate`.
12. Обновление `current` отслеживает, какая часть пула уже выделена, позволяя аллокатору последовательно распределять память без пересечений.

@return
Возвращается указатель `aligned_ptr` (типа `std::uint8_t*`), приведённый к `void*` в соответствии с сигнатурой функции.
Возвращение `void*` обеспечивает универсальность, позволяя вызывающему коду привести указатель к любому нужному типу (например, `double*` или `struct MyType*`). Это стандартная практика для аллокаторов, работающих с сырой памятью.
Вызывающий код получает выровненный адрес памяти, готовый для использования.

@par Пример:
@code
AlignedAllocator alloc(1024, 64);
void* ptr = alloc.allocate(256); // Выделяет блок размером 256 байт, выровненный по 64 байта
@endcode

@warning
- Убедитесь, что `size` не равен нулю, так как выделение блока нулевого размера может привести к неопределённому поведению или пустому выделению, в зависимости от реализации.
- Если запрашиваемый `size` слишком велик и выходит за пределы пула (`base + pool_size`), метод выбросит `std::bad_alloc`. Проверьте доступный размер пула перед вызовом.
- Выравнивание, установленное в конструкторе, должно быть степенью двойки. Некорректное выравнивание может привести к неправильным адресам, хотя метод сам по себе это не проверяет.
*/