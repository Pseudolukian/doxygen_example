/**
@ingroup AllocatorGroup
@class AlignedAllocator
@fn allocate(std::size_t size)
@brief Выделяет блок памяти из пула.

@details Метод @ref AlignedAllocator::allocate(std::size_t size) выделяет блок памяти из пула, гарантируя, что возвращаемый указатель выровнен по границе, заданной параметром `alignment` конструктора. Последующие выделения также сохраняют правильное выравнивание. Метод выполняет арифметику указателей и побитовые операции для вычисления выровненного адреса, проверяет границы пула и обновляет текущую позицию для следующих выделений.

Метод возвращает универсальный указатель типа void*, который может указывать на данные любого типа. Он позволяет вызывающему коду самостоятельно привести указатель к нужному типу (например, `int*` или `float*`), обеспечивая гибкость.

Указатель `current` (типа `std::uint8_t*`), указывающий на текущую позицию в пуле памяти, преобразуется в целое число типа `std::uintptr_t` с помощью `reinterpret_cast` (так как указатели (`std::uint8_t*`) нельзя напрямую использовать для побитовых операций):
@code{c++}
std::uintptr_t curr = reinterpret_cast<std::uintptr_t>(current);
@endcode

Преобразование позволяет выполнять арифметические и побитовые операции на адресе памяти. Тип `std::uintptr_t` гарантирует, что адрес указателя можно безопасно хранить и манипулировать как числом.

Конструкция `std::uintptr_t aligned = (curr + alignment - 1) & ~(alignment - 1);` вычисляет следующий выровненный адрес памяти, кратный значению `alignment`. Это делается с помощью двух шагов:
    - `curr + alignment - 1` — округляет текущий адрес вверх, добавляя `alignment - 1`. Это гарантирует, что результат будет не меньше следующей границы выравнивания. Например, если `curr = 100` и `alignment = 16`, то `100 + 16 - 1 = 115`.
    - `~(alignment - 1)`— создаёт битовую маску для очистки младших битов адреса. Например, для `alignment = 16` (двоичное `10000`), `alignment - 1 = 15` (двоичное `01111`), а `~(alignment - 1) = ~01111 = 11110000` (в шестнадцатеричной системе `0xFFFFFFF0` для 32 бит). Эта маска обнуляет младшие биты, соответствующие значению выравнивания.
    - Побитовая операция `&` применяет маску к округлённому адресу, обнуляя младшие биты, чтобы получить адрес, кратный `alignment`. Для примера выше: `115 & 0xFFFFFFF0 = 112` (двоичное `1110000`), что кратно 16.

Выравнивание адреса необходимо, чтобы возвращаемый указатель соответствовал требованиям `alignment` (например, 16 или 64 байта), что критично для оптимизаций (например, SIMD-инструкций) или аппаратных требований.

Переменная `aligned` теперь содержит числовое значение выровненного адреса, которое затем преобразуется обратно в указатель типа `std::uint8_t*` с помощью `reinterpret_cast`. Это позволяет использовать его для доступа к памяти:
@code{c++}
std::uint8_t* aligned_ptr = reinterpret_cast<std::uint8_t*>(aligned);
@endcode

На этапе `if (aligned_ptr + size > base + pool_size) { throw std::bad_alloc(); }` проверяется, помещается ли запрашиваемый блок памяти размером `size`, начиная с выровненного адреса `aligned_ptr`, в пределах пула памяти.
**Логика работы**:
    - Выражение `aligned_ptr + size` вычисляет адрес, следующий за концом запрашиваемого блока (конец выделяемого участка).
    - Выражение `base + pool_size` определяет конец пула памяти, где `base` — начальный адрес пула, а `pool_size` — его общий размер.
    - Если `aligned_ptr + size` превышает `base + pool_size` — выделение невозможно, так как блок выходит за границы пула.

Такая проверка предотвращает переполнение пула, гарантируя, что аллокатор не выделит память за пределами доступного пространства. Если выделение невозможно, выбрасывается исключение `std::bad_alloc`, сигнализирующее вызывающему коду, что памяти недостаточно.

На этапе `current = aligned_ptr + size;` указатель `current` обновляется, чтобы указывать на адрес, следующий за выделенным блоком (`aligned_ptr + size`). Это перемещает текущую позицию в пуле, подготавливая её для следующего вызова `allocate`. Обновление `current` отслеживает, какая часть пула уже выделена, позволяя аллокатору последовательно распределять память без пересечений.

@param[in] size Запрашиваемый размер блока в байтах.
@var AlignedAllocator::allocate::curr Указатель на текущую позицию в пуле памяти.
@var AlignedAllocator::allocate::aligned Следуюший выровненный адрес в памяти
@var AlignedAllocator::allocate::aligned_ptr Указатель на выровненный адрес в памяти
@var AlignedAllocator::current Указатель на текущую позицию в пуле памяти.
@throw std::bad_alloc Поднимается исключение, если запрашиваемый размер памяти превышает объём пула.
@return
Указатель `aligned_ptr` (типа `std::uint8_t*`), приведённый к `void*` в соответствии с сигнатурой функции. Возвращение `void*` обеспечивает универсальность, позволяя вызывающему коду привести указатель к любому нужному типу (например, `double*` или `struct MyType*`).
/*