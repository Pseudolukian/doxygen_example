/**
@ingroup AllocatorGroup
@fn void AlignedAllocator::reset()
@brief Сбрасывает аллокатор в начальное состояние.

@details
Метод сбрасывает текущую позицию в пуле памяти к его началу, возвращая указатель `current` к значению `base`. Это позволяет аллокатору начать выделение памяти заново, как если бы пул только что был создан. Все ранее выделенные блоки памяти, полученные через @ref AlignedAllocator::allocate "allocate()", становятся недействительными, так как последующие вызовы `allocate` могут перезаписать их содержимое.
После вызова `reset`, последующие вызовы @ref AlignedAllocator::allocate "allocate()" начнут выделять память с начала пула (`base`), игнорируя ранее выделенные блоки. Это отличается от деструктора (@ref AlignedAllocator::~AlignedAllocator "~AlignedAllocator()"), который освобождает память через `std::free`.
@warning
Все указатели, возвращённые предыдущими вызовами `allocate`, становятся недействительными, так как новые выделения могут перезаписать их содержимое. Попытка доступа к таким указателям приведёт к неопределённому поведению (например, к чтению неверных данных или сбоям программы).
Метод не выбрасывает исключений, так как выполняет простое присваивание указателя, и не требует дополнительных проверок, поскольку `base` гарантированно установлен в конструкторе.

@par Пример:
@code
AlignedAllocator alloc(1024, 64);
void* ptr1 = alloc.allocate(256); // Выделяет 256 байт
alloc.reset();                    // Сбрасывает аллокатор
void* ptr2 = alloc.allocate(128); // Новый блок перезапишет начало пула
// ptr1 теперь недействителен!
@endcode
*/