/**
@ingroup Logger_Group
@fn LogBuffer::log(LogLevel level, const char* message)
@brief Добавляет запись лога в очередь.

@details
Создает новую запись лога с указанным уровнем и сообщением, выделяя память через аллокатор, и добавляет ее в очередь. Выделение памяти защищено мьютексом.

Сначала создаётся блокировка `std::lock_guard<std::mutex> guard(mutex);` Это обеспечивает сериализацию доступа к аллокатору (`allocator`), так как он не является потокобезопасным. Блокировка удерживается до конца области видимости метода (до завершения log), гарантируя, что только один поток может выполнять выделение памяти одновременно.

Далее инициализируется указатель на память `void* mem = nullptr;`. Указатель будет использоваться для хранения адреса выделенной памяти под объект `LogEntry`.

В блоке `try`:
@code{c++}
try {
    mem = allocator.allocate(sizeof(LogEntry));
} catch (const std::bad_alloc&) {
    return false;
}
@endcode

вызывается метод `allocator.allocate`, который пытается выделить память размером `sizeof(LogEntry)` (размер структуры `LogEntry`, выровненной по 64 байта, как указано в `log_entry.h`). Если выделение памяти проходит успешно, `mem` получает адрес выделенного блока памяти. Если метод allocator.allocate выбрасывает исключение std::bad_alloc (например, из-за нехватки памяти в пуле аллокатора), оно перехватывается в блоке catch.

В этом случае метод `log` немедленно возвращает `false`, сигнализируя, что запись в лог не удалась из-за невозможности выделить память. Блокировка мьютекса автоматически снимается при выходе из метода (деструктор std::lock_guard).

Если память успешно выделена, используется `placement new` для создания объекта LogEntry по адресу mem:
@code{c++}
LogEntry* entry = new (mem) LogEntry(level, message);
@endcode

В финале, вызывается метод `queue.enqueue(entry)`, где `queue` — это объект класса `LockFreeQueue<LogEntry>`.Метод `enqueue` пытается добавить указатель `entry` в очередь без использования блокировок (lock-free реализация).
enqueue возвращает:
- `true`, если запись успешно добавлена в очередь (есть свободное место).
- `false`, если очередь полна (условие `next_tail == head` в lock_free_queue.h).

Результат `enqueue` напрямую возвращается из метода log через `return queue.enqueue(entry)`;. После этого мьютекс автоматически освобождается (деструктор `std::lock_guard`).

@par [in] level Уровень логирования (INFO, WARNING, ERROR).
@par [in] message Текстовое сообщение лога (C-строка).
@return true, если запись добавлена успешно; false, если выделение памяти не удалось или очередь полна.
@throw bad_alloc Если не удалось выделить память для новой записи лога.
*/