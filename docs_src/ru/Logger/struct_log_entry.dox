/**
@ingroup Logger_Group
@struct LogEntry
@brief
Структура (выравнивается по 64 байтам) для хранения записи лога с временной меткой, идентификатором потока, уровнем логирования и сообщением.

@details
Структура LogEntry используется для создания записей логов в файл следующего вида:
@code{text}
[21961115] [TID 139925989566144] [INFO] Log message from producer thread
...
@endcode

@var LogEntry::timestamp
Временная метка события, фиксируемая в момент создания записи. Использует std::chrono::steady_clock для обеспечения монотонного времени.
@var LogEntry::thread_id
Идентификатор потока, в котором была создана запись. Использует std::thread::id для уникальной идентификации потока.
@var LogEntry::level
Уровень логирования (INFO, WARNING, ERROR). Использует перечисление LogLevel для определения уровня серьезности сообщения.
@var LogEntry::message
Массив символов фиксированной длины (256 байт) для хранения текстового сообщения. Использует std::strncpy для безопасного копирования строки и гарантирует завершение нулевым символом.

@fn LogEntry::LogEntry()
@brief Конструктор по умолчанию. 
Конструктор необходим для инициализации структуры в контейнерах, массивах или других структурах данных, где требуется создание объектов без параметров. 
Поля структуры остаются неинициализированными, что предполагает их последующую явную инициализацию или использование параметризованного конструктора.

@fn LogEntry::LogEntry(LogLevel lvl, const char* msg) 
@brief Параметризованный конструктор. 
Инициализирует все поля структуры:
- Устанавливает `timestamp` в текущее время с помощью std::chrono::steady_clock::now().
- Фиксирует `thread_id` текущего потока через std::this_thread::get_id().
- Присваивает `level` переданное значение из перечисления LogLevel.
- Копирует переданное сообщение msg в поле message с помощью std::strncpy.

@note Размер поля `message` ограничен 256 символами. Если переданное сообщение длиннее, оно будет усечено.
Для сообщений большей длины рекомендуется использовать альтернативные механизмы логирования.

@warning В многопоточных приложениях необходимо обеспечить синхронизацию доступа к общему хранилищу логов, так как сама структура не предоставляет встроенных механизмов синхронизации.
*/